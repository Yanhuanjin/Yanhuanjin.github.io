<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习总结(基础篇)</title>
      <link href="2021/03/29/ji-qi-xue-xi-zong-jie-ji-chu-pian/"/>
      <url>2021/03/29/ji-qi-xue-xi-zong-jie-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-什么是机器学习？"><a href="#1-1-什么是机器学习？" class="headerlink" title="1.1 什么是机器学习？"></a>1.1 什么是机器学习？</h2><p>机器学习通过算法，对已知数据进行建模，然后用这个模型对新出现的或新得到的数据做出预测或判断。了解机器学习的原理，是解开人工智能这个黑盒子最好的钥匙。<br>机器学习分为监督学习和无监督学习，常见的机器学习算法分类如下</p><p></p><div class="wiz-table-container" style="position: relative; padding: 0px;" contenteditable="false"><div class="wiz-table-body" contenteditable="false"><table style="width: 361px;"><tbody><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff">算法名称</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff">监督学习</td><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff">无监督学习</td></tr><tr style="height: 35px;"><td align="center" valign="middle" style="width: 120px;">线性回归</td><td align="center" valign="middle" style="width: 120px;">√</td><td align="center" valign="middle" style="width: 120px;"><br></td></tr><tr><td align="center" valign="middle" style="width: 120px;">逻辑回归</td><td align="center" valign="middle" style="width: 120px;"><span>√</span></td><td align="center" valign="middle" style="width: 120px;"><br></td></tr><tr><td align="center" valign="middle" style="width: 120px;">k-近邻</td><td align="center" valign="middle" style="width: 120px;"><span>√</span></td><td align="center" valign="middle" style="width: 120px;"><br></td></tr><tr><td style="width: 120px;" align="center">支持向量机</td><td style="width: 120px;" align="center"><span>√</span></td><td style="width: 120px;" align="center"><br></td></tr><tr><td style="width: 120px;" align="center">决策树</td><td style="width: 120px;" align="center"><span>√</span></td><td style="width: 120px;" align="center"><br></td></tr><tr><td style="width: 120px;" align="center">随机森林</td><td style="width: 120px;" align="center"><span>√</span></td><td style="width: 120px;" align="center"><br></td></tr><tr><td style="width: 120px;" align="center">提升方法（GBM）</td><td style="width: 120px;" align="center"><span>√</span></td><td style="width: 120px;" align="center"><br></td></tr><tr><td style="width: 120px;" align="center">神经网络</td><td style="width: 120px;" align="center"><span>√</span></td><td style="width: 120px;" align="center"><br></td></tr><tr><td style="width: 120px;" align="center">主成分分析（PCA）</td><td style="width: 120px;" align="center"><br></td><td style="width: 120px;" align="center"><span>√</span></td></tr><tr><td style="width: 120px;" align="center">聚类分析</td><td style="width: 120px;" align="center"><br></td><td style="width: 120px;" align="center"><span>√</span></td></tr></tbody></table></div>&lt;/div&gt;</div><p></p><h2 id="1-2-机器学习基本概念汇总"><a href="#1-2-机器学习基本概念汇总" class="headerlink" title="1.2 机器学习基本概念汇总"></a>1.2 机器学习基本概念汇总</h2><h3 id="1-均方误差"><a href="#1-均方误差" class="headerlink" title="1.    均方误差"></a>1.    均方误差</h3><script type="math/tex; mode=display">{\hat f_n} = arg\displaystyle\min_{f}\frac{1}{n}\displaystyle\sum_{i=1}^n(f(X_i)-y_i)^2</script><p>其中，$X_i$为输入，$y_i$为输入对应的标签值，$f(X_i)$为预测值。就是对预测结果和实际结果的误差取平均。</p><h3 id="2-最大似然估计"><a href="#2-最大似然估计" class="headerlink" title="2.    最大似然估计"></a>2.    最大似然估计</h3><script type="math/tex; mode=display">\hat\beta_{MLE} = arg\displaystyle\max_{\beta}logp(\displaystyle\{X_i, Y_i\}_{i=1}^n|\beta)</script><p>即在模型参数为$\beta$的情况下，训练样本$X_i$正好对应为$Y_i$出现的条件概率，取最大条件概率，即为最佳模型参数。</p><h3 id="3-贝叶斯理论"><a href="#3-贝叶斯理论" class="headerlink" title="3.    贝叶斯理论"></a>3.    贝叶斯理论</h3><script type="math/tex; mode=display">P(\theta|X)=\frac{P(X|\theta)P(\theta)}{P(X)}</script><p>$P(\theta)$表示先验分布，$\theta$表示模型参数集，等式左边为后验分布。<br>因此，贝叶斯理论推断可以分为先验、似然、后验三个步骤。</p><h3 id="4-凸优化"><a href="#4-凸优化" class="headerlink" title="4.    凸优化"></a>4.    凸优化</h3><script type="math/tex; mode=display">f(\alpha{x}+\beta{y})\leq{\alpha}f(x)+{\beta}f(y)</script><p>其中$x,y \in R^n$，${\alpha},{\beta} \in R$，且${\alpha}\geq0$，${\beta}\geq0$，${\alpha} + {\beta} =1$<br>凸优化有唯一最优解。</p><h3 id="5-混淆矩阵"><a href="#5-混淆矩阵" class="headerlink" title="5.    混淆矩阵"></a>5.    混淆矩阵</h3><p>横轴为预测值，纵轴为实际值。</p><p></p><div class="wiz-table-container" style="position: relative; padding: 0px;" contenteditable="false"><div class="wiz-table-body" contenteditable="false"><table style="width: 361px;"><tbody><tr><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff"><br></td><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff"><span>预测为阳性</span></td><td align="center" valign="middle" style="width: 120px; background-color: rgb(209, 230, 255);" data-background-color="#d1e6ff"><span>预测为阴性</span></td></tr><tr><td align="center" valign="middle" style="width:120px"><span>实际为阳性</span></td><td align="center" valign="middle" style="width:120px"><span>TP</span></td><td align="center" valign="middle" style="width:120px">FN</td></tr><tr><td align="center" valign="middle" style="width:120px"><span>实际为阴性</span></td><td align="center" valign="middle" style="width:120px">FP</td><td align="center" valign="middle" style="width:120px">TN</td></tr></tbody></table></div>&lt;/div&gt;</div><p></p><h3 id="6-准确率、精确度、召回率和F1评分"><a href="#6-准确率、精确度、召回率和F1评分" class="headerlink" title="6.    准确率、精确度、召回率和F1评分"></a>6.    准确率、精确度、召回率和F1评分</h3><p>（1）准确率(Accuracy)</p><script type="math/tex; mode=display">Accuracy=\frac{TP+TN}{TP+FN+FP+TN}</script><p>即预测准确的个数，占总预测数的比例<br>（2）召回率(Recall)</p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><p>即预测为真阳性的数目，占所有阳性的比率<br>（3）精确度(Precision)</p><script type="math/tex; mode=display">Precison=\frac{TP}{TP+FP}</script><p>即预测为真阳性的个数，占所有预测为阳性的比率<br>（4）F1评分</p><script type="math/tex; mode=display">F1=2\frac{Precision{\times}Recall}{Precision+Recall}</script><h3 id="7-ROC曲线"><a href="#7-ROC曲线" class="headerlink" title="7.    ROC曲线"></a>7.    ROC曲线</h3><p>横轴为假阳性率，纵轴为真阳性率，曲线越陡峭，说明结果越好，曲线下面积（AUC）越大。</p><h3 id="8-正则化"><a href="#8-正则化" class="headerlink" title="8.    正则化"></a>8.    正则化</h3><p>（1）Lasso正则化（L1正则化），系数绝对值总和，乘以惩罚项$\gamma$，特点是可以使无用的系数降为0。<br>（2）Ridge回归（L2正则化），系数值的平方和，乘以惩罚项$\gamma$，无法将无用的系数降为0。</p><h3 id="9-交叉验证"><a href="#9-交叉验证" class="headerlink" title="9.    交叉验证"></a>9.    交叉验证</h3><p>（1）留一法（Leave-one-out）<br>留一个数据项作为验证，其余参与训练。对于N个数据集的数据，需要进行N次训练。<br>（2）K折交叉验证法（K-fold）<br>将数据集分为K折，K-1个部分用于训练，1个部分用于验证，所以只需要K次训练。为了避免数据集过于集中带来的误差，在做K折交叉验证之前，需要进行随机洗牌（Shuffle）。</p><h3 id="10-Sigmoid函数"><a href="#10-Sigmoid函数" class="headerlink" title="10.    Sigmoid函数"></a>10.    Sigmoid函数</h3><script type="math/tex; mode=display">f(x)=\frac{1}{1+e^{-x}}</script><h3 id="11-标准化缩放（Standardize-Scaler）"><a href="#11-标准化缩放（Standardize-Scaler）" class="headerlink" title="11.    标准化缩放（Standardize Scaler）"></a>11.    标准化缩放（Standardize Scaler）</h3><script type="math/tex; mode=display">z=\frac{x-\mu}{s}</script><p>其中$\mu$是训练样本平均数，$s$是训练样本标准差</p><h3 id="12-分类问题损失函数（Cost-function）"><a href="#12-分类问题损失函数（Cost-function）" class="headerlink" title="12.    分类问题损失函数（Cost function）"></a>12.    分类问题损失函数（Cost function）</h3><p>交叉熵<script type="math/tex">cross\_entropy=-\displaystyle\sum_{i=1}^Cy_i\ln (p_i)</script><br>其中，$C$为分类数目，当$C=2$时，成为二分类问题，</p><script type="math/tex; mode=display">cross\_entropy=-y_1\ln(p_1) -y_2\ln(p_2)=-y_1\ln(p_1) -(1-y_1)\ln(1-p_1)</script><h3 id="13-Softmax函数"><a href="#13-Softmax函数" class="headerlink" title="13.    Softmax函数"></a>13.    Softmax函数</h3><p>将任意输出$z_i$转化为概率，</p><script type="math/tex; mode=display">softmax(z_i)=\frac{e^{z_i}}{\displaystyle\sum_{j=1}^Ce^{z_j}}</script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python行云流水地操作Excel和数据库</title>
      <link href="2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/"/>
      <url>2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本想就着这个机会学习下Java读取Excel的，奈何搜了一圈，发现还是Pandas最为简单明了。打算先就Python写一版，后面在学习时可能还会发一篇《用Java优雅地操作Excel和数据库》。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><p>关于软件安装和环境配置，网上有成堆的教程，此处不再赘述。<br>大体上需要用到的软件就以下几款：</p><ol><li>Anaconda（建议用Anaconda里的jupyter notebook，如果喜欢PyCharm也可以，当然也可以只用Python）</li><li>Python（Anaconda和PyCharm都内置，如果只有Python也可）</li><li>MySQL（不多说了，免费）</li></ol><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据只要随便找一个Excel文件，自己建一个Excel文档（不论是.xls还是.xlsx后缀都可以），并随便写一些内容，保存为 成绩单.xlsx。<br><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/1.png" alt=""></p><h2 id="Pandas读取Excel文件"><a href="#Pandas读取Excel文件" class="headerlink" title="Pandas读取Excel文件"></a>Pandas读取Excel文件</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pandas as pd  # 如果没有安装pandas报错，直接在jupyter里面运行后述语句 !pip install pandasdf = pd.read_excel(r"C:\Users\Administrator\Desktop\成绩单.xlsx")  # 读取test.xlsx的sheet1，并以第一行作为Dataframe的标题头df.head()  # 查看表格内容概况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/2.png" alt=""></p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>打开MySQL，创建数据库students</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 创建数据库create database students;# 使用数据库use database;# 查看数据表，这个时候是空数据库show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">create table `students` (`id` int not null auto_increment primary key, `student_id` varchar(255) comment '学号', `name` varchar(255) comment '姓名', `results` int comment '成绩');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：创建数据表有两种方式，一种是在MySQL中先创建好数据表，并定义好数据字段的名称、属性，然后再用Pandas进行导入，若属性不符则导入失败；另一种是直接用Pandas在导出的同时创建数据表，这样导出的数据表字段属性都为TEXT，然后根据需要更改数据字段属性。</p><h2 id="将记录导入数据库"><a href="#将记录导入数据库" class="headerlink" title="将记录导入数据库"></a>将记录导入数据库</h2><p>调用Pandas.io.sql.to_sql()方法，其中if_exists控制重复记录是替换还是追加。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from sqlalchemy import create_engine# 建立连接，username替换为用户名，passwd替换为密码，students替换为数据库名conn = create_engine('mysql+pymysql://username:passwd@localhost:3306/students',encoding='utf8')# 以df中的header为标题，写入数据库，test替换为数据表名pd.io.sql.to_sql(df, "students", conn, if_exists='append', index=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般这时候会报错，因为Pandas里面的字段名称和数据库里的字段名称不一致<br><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/3.png" alt=""><br>修改df里面的标题(几种重命名的方式汇总 <a href="https://blog.csdn.net/littleRpl/article/details/100117428">https://blog.csdn.net/littleRpl/article/details/100117428</a>)</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">df.rename(columns={'学号':'student_id',                  '姓名':'name',                  '成绩':'results'},inplace=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/4.png" alt=""><br>再次尝试写入，成功。我们直接查询student数据表</p><p><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/5.png" alt=""></p><h2 id="使用PyMySQL连接数据库进行增删改查"><a href="#使用PyMySQL连接数据库进行增删改查" class="headerlink" title="使用PyMySQL连接数据库进行增删改查"></a>使用PyMySQL连接数据库进行增删改查</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pymysqldb = pymysql.connect(host="127.0.0.1", user="root", database="students", passwd="root")  # 主机名，用户名，数据库名称，密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">cursor = db.cursor()# 编写查询语句sql = "SELECT * FROM test;"# 执行查询语句cursor.execute(sql)# 获取查询结果result = cursor.fetchall()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到返回的是一个二维元组<br><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/6.png" alt=""></p><h3 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h3><h4 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">insert_sql = "INSERT INTO students (student_id, name, results) values ('Y031', 'Jack', 99);"cursor.execute(insert_sql)db.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/7.png" alt=""></p><h4 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">update_sql = "update students set student_id='Y006' where student_id='Y031';"cursor.execute(update_sql)db.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/8.png" alt=""></p><h4 id="删除记录（不建议，一般使用逻辑删除，即新增一个is-delete字段，然后update这个字段）"><a href="#删除记录（不建议，一般使用逻辑删除，即新增一个is-delete字段，然后update这个字段）" class="headerlink" title="删除记录（不建议，一般使用逻辑删除，即新增一个is_delete字段，然后update这个字段）"></a>删除记录（不建议，一般使用逻辑删除，即新增一个is_delete字段，然后update这个字段）</h4><p>同样的也是套用上面的模板进行操作，读者可以自行尝试。<br>这里稍微讲一下逻辑删除的原理，由于我进行了一次物理删除，导致自增id跳过6到了7.<br>如果是逻辑删除，先修改表结构新增is_delete字段<br><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/9.png" alt=""><br>更新指定主键的记录的is_delete属性为1，查询的时候加上限定条件。<br><img src="/2021/02/10/yong-python-xing-yun-liu-shui-cao-zuo-shu-ju-ku/10.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过Python操作数据库和Excel文件，以Pandas为桥梁，就可以快速进行Excel数据分析，Pandas数据处理，MySQL数据库存储，实现全流程自动化操作。通过数据库连接Web开发组件，Pandas连接机器学习，Excel导出统计报表，实现一站式编程。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop分布式集群配置错误解决记录</title>
      <link href="2021/01/21/hadoop-fen-bu-shi-ji-qun-pei-zhi-cuo-wu-jie-jue-ji-lu/"/>
      <url>2021/01/21/hadoop-fen-bu-shi-ji-qun-pei-zhi-cuo-wu-jie-jue-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>继上次配置好hadoop真分布式之后，这次启动后，调用hdfs命令总是报错，拒绝9000远程访问，但是端口还是好的（未占用）。搜了一圈网上的解决方案，一个个试过去都不行，最后导致namenode都起不来了，心态差点崩了，就差重新装一遍了。</p><p><img src="/2021/01/21/hadoop-fen-bu-shi-ji-qun-pei-zhi-cuo-wu-jie-jue-ji-lu/1732977-20210121144036263-2132110927.jpg" alt=""></p><h2 id="2-排查问题"><a href="#2-排查问题" class="headerlink" title="2.排查问题"></a>2.排查问题</h2><p>后来静下心来慢慢排查，去看logs文件夹下master的日志文件，才知道问题出在哪，namenode没有格式化</p><pre><code>2021-01-21 14:09:36,639 FATAL org.apache.hadoop.hdfs.server.namenode.NameNode: Failed to start namenode.java.io.IOException: NameNode is not formatted.</code></pre><p>然后尝试格式化namenode，</p><p><code>hdfs namenode -format</code></p><p>报错，报错日志如下图，<br><img src="/2021/01/21/hadoop-fen-bu-shi-ji-qun-pei-zhi-cuo-wu-jie-jue-ji-lu/1732977-20210121141441519-125675234.png" alt=""></p><h2 id="3-解决方式"><a href="#3-解决方式" class="headerlink" title="3.解决方式"></a>3.解决方式</h2><p>仔细看了下各个配置文件，发现core-site.xml在配置tmp路径时，多加了个file:，会不会是因为这个？（当时第一感觉就觉得这里不对，但是看网上教程好像都成功了？所以就照做了。现在看来，不能太过信任网上的所谓的最全、最详细教程啊！）<br><img src="/2021/01/21/hadoop-fen-bu-shi-ji-qun-pei-zhi-cuo-wu-jie-jue-ji-lu/202101/1732977-20210121141708097-226277289.png" alt=""><br>修改完后，再次格式化namenode文件夹，成功。<br><code>hdfs namenode -format</code></p><p>然后再启动服务，</p><p>开启hdfs服务</p><pre><code>hduser@master:/usr/local/hadoop/etc/hadoop$ start-dfs.shStarting namenodes on [master]master: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hduser-namenode-master.outdata2: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hduser-datanode-data2.outdata3: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hduser-datanode-data3.outdata1: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hduser-datanode-data1.outStarting secondary namenodes [0.0.0.0]0.0.0.0: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-hduser-secondarynamenode-master.outhduser@master:/usr/local/hadoop/etc/hadoop$ jps4375 Jps4273 SecondaryNameNode4046 NameNode</code></pre><p>开启yarn服务</p><pre><code>hduser@master:/usr/local/hadoop/etc/hadoop$ start-yarn.shstarting yarn daemonsstarting resourcemanager, logging to /usr/local/hadoop/logs/yarn-hduser-resourcemanager-master.outdata2: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hduser-nodemanager-data2.outdata1: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hduser-nodemanager-data1.outdata3: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hduser-nodemanager-data3.outhduser@master:/usr/local/hadoop/etc/hadoop$ jps4507 Jps4273 SecondaryNameNode4428 ResourceManager4046 NameNode</code></pre><p>可以看到，这次服务都成功起来了。创建hdfs目录，并且查看，也成功。</p><pre><code>hduser@master:/usr/local/hadoop/etc/hadoop$ hadoop fs -mkdir /testhduser@master:/usr/local/hadoop/etc/hadoop$ hadoop fs -ls /Found 1 itemsdrwxr-xr-x   - hduser supergroup          0 2021-01-21 14:23 /test</code></pre><h2 id="4-总结体会"><a href="#4-总结体会" class="headerlink" title="4.总结体会"></a>4.总结体会</h2><h3 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h3><p>如果出现9000端口拒绝访问，一般是以下两者之一：<br>1.端口配置（端口冲突等）、防火墙<br>2.tmp文件夹配置（实践证明我的错误应是这种，由于没有指定tmp文件夹，导致每次都要重新格式化namenode，不然找不到tmp/dfs下的name和namesecondary就会导致服务起不来）</p><h3 id="2-体会"><a href="#2-体会" class="headerlink" title="2.体会"></a>2.体会</h3><p>还是得独立思考、研究，遇问题多看LOG，一昧找答案并不靠谱（还看到多个一模一样的答案，不知道他们是怎么都解决的）。</p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始Django搭建Python Web项目</title>
      <link href="2020/11/10/cong-ling-kai-shi-da-jian-django-xiang-mu/"/>
      <url>2020/11/10/cong-ling-kai-shi-da-jian-django-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始：Django搭建Web"><a href="#从零开始：Django搭建Web" class="headerlink" title="从零开始：Django搭建Web"></a>从零开始：Django搭建Web</h1><p>Created: Oct 29, 2020 10:39 AM<br>Updated: Nov 10, 2020 2:01 PM</p><ol><li><p>在任意存储位置，新建文件夹，例如DjangoTest。</p><p> <img src="/2020/11/10/cong-ling-kai-shi-da-jian-django-xiang-mu/创建文件夹.png" alt="创建文件夹"></p></li><li><p>在资源管理器地址栏键入cmd，进入命令行界面（对，直接在这里键入cmd）。</p><p> <img src="/2020/11/10/cong-ling-kai-shi-da-jian-django-xiang-mu/打开命令行.png" alt="打开命令行"></p></li><li><p>创建虚拟环境</p><p> 这里环境名称我用test。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> python -m venv test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>激活虚拟环境</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> test\Scripts\activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以看到前面多了一个括号，括号内时虚拟环境的名称</p><p> <img src="/2020/11/10/cong-ling-kai-shi-da-jian-django-xiang-mu/激活虚拟环境.png" alt="激活虚拟环境"></p></li><li><p>使用pip安装Django</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> pip install Django<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在Django中创建项目</p><p> 使用PyCharm打开DjangoTest文件夹，在Terminal窗口中输入</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> django-admin.py startproject my_blog .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建数据库</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> python manage.py migrate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动服务器</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"> python manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot注解说明@RequestMapping</title>
      <link href="2020/11/03/java-zhu-jie-requestmapping/"/>
      <url>2020/11/03/java-zhu-jie-requestmapping/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>@RequestMapping注解可以将HTTP请求映射给控制器controller来处理，包括返回视图页面的controller和Rest服务的controller。是一个非常常用的注解。</strong></p></blockquote><p>在 Spring MVC 应用程序中，RequestDispatcher (在 Front Controller 之下) 这个 servlet 负责将进入的 HTTP 请求路由到控制器的处理方法。在对 Spring MVC 进行的配置的时候, 需要指定请求与处理方法之间的映射关系。如下图：</p><p><img src="https://img-blog.csdnimg.cn/20181219193206597" alt="img"></p><p>要配置 Web 请求的映射，就需要你用上 @RequestMapping 注解。@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {    @RequestMapping("/")          String get() {        //mapped to hostname:port/home/         return "Hello from get";     }         @RequestMapping("/index")    String index() {        //mapped to hostname:port/home/index/        return "Hello from index";     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上述代码所示，到 /home 的请求会由 get() 方法来处理，而到 /home/index 的请求会由 index() 来处理。</p><p><strong>@RequestMapping 来处理多个 URI</strong></p><p>你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了。</p><pre class="line-numbers language-lang-Java"><code class="language-lang-Java">@RestController  @RequestMapping("/home")  public class IndexController {            @RequestMapping(value = {                  "",         "/page",           "page*",           "view/*,**/msg"    })         String indexMultipleMapping() {                return "Hello from index multiple mapping.";       } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>带有 @RequestParam 的 @RequestMapping</strong></p><p>@RequestParam 注解配合 @RequestMapping 一起使用，可以将请求的参数同处理方法的参数绑定在一起。@RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数, 代码如下所示：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {            @RequestMapping(value = "/id")          String getIdByValue(@RequestParam("id") String personId) {        System.out.println("ID is " + personId);                  return "Get ID from query string of URL with value element";         }          @RequestMapping(value = "/personId") String getId(@RequestParam String personId) {       # 如果请求参数和处理方法参数的名称一样的话，@RequestParam 注解的value 这个参数就可省掉             System.out.println("ID is " + personId);                  return "Get ID from query string of URL without value element";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@RequestParam 注解的 required 这个参数定义了参数值是否是必须要传的。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/name")          String getName(@RequestParam(value = "person", required = false) String personName) {        return "Required element of request param";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于required被指定为false，故对于getName()方法来说，对于如下两个url均会处理：</p><p>/home/name?person=xyz<br>/home/name</p><p>@RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/name")    String getName(@RequestParam(value="person", defaultValue ="John") String personName) {                    return "Required element of request param";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若请求中没有”person=”的参数，那么getName()处理方法就会接受John这个默认值作为其参数。</p><p><strong>用 @RequestMapping 处理 HTTP 的各种方法</strong></p><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。所有的请求默认都会是 HTTP GET 类型的。为了能将一个请求映射到一个特定的 HTTP 方法，你需要在 @RequestMapping 中使用 method 来声明 HTTP 请求所使用的方法类型，如下所示：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(method = RequestMethod.GET)          String get() {                  return "Hello from get";          }          @RequestMapping(method = RequestMethod.DELETE)    String delete() {                 return "Hello from delete";          }          @RequestMapping(method = RequestMethod.POST)          String post() {                  return "Hello from post";          }          @RequestMapping(method = RequestMethod.PUT)          String put() {                  return "Hello from put";          }          @RequestMapping(method = RequestMethod.PATCH)          String patch() {                  return "Hello from patch";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述这段代码中， @RequestMapping 注解中的 method 元素声明了 HTTP 请求的 HTTP 方法的类型。所有的处理处理方法会处理从这同一个 URL( /home)进来的请求, 但要看指定的 HTTP 方法是什么来决定用哪个方法来处理。例如，一个 POST 类型的请求 /home 会交给 post() 方法来处理，而一个 DELETE 类型的请求 /home 则会由 delete() 方法来处理。你会看到 Spring MVC 将使用这样相同的逻辑来映射其它的方法。</p><p><strong>用 @RequestMapping 来处理生产和消费对象</strong></p><p>可以使用 @RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围。为了能用请求的媒体类型来产生对象, 你要用到 @RequestMapping 的 produces 元素再结合着 @ResponseBody 注解。你也可以利用 @RequestMapping 的 comsumes 元素再结合着 @RequestBody 注解用请求的媒体类型来消费对象。下面这段代码就用到的 @RequestMapping 的生产和消费对象元素：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/prod", produces = {"application/JSON"})          @ResponseBody          String getProduces() {                  return "Produces attribute";          }            @RequestMapping(value = "/cons", consumes = {                  "application/JSON",                  "application/XML"          })          String getConsumes() {                  return "Consumes attribute";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，getProduces()处理方法会产生一个JSON响应，同理，getConsumes()方法可以同时处理请求中的JSON和XML内容。使用@RequestMapping来处理消息头@RequestMapping注解提供了一个header元素来根据请求中的消息头内容缩小请求映射的范围。在可以指定header元素的值，用myHeader = myValue 这样的格式：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/head", headers = {"content-type=text/plain"})          String post() {                  return "Mapping applied along with headers";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这段代码中， @RequestMapping 注解的 headers 属性将映射范围缩小到了 post() 方法。有了这个，post() 方法就只会处理到 /home/head 并且 content-typeheader 被指定为 text/plain 这个值的请求。你也可以像下面这样指定多个消息头：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/head", headers = {                  "content-type=text/plain",                  "content-type=text/html"          })     String post() {                  return "Mapping applied along with headers";          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样， post() 方法就能同时接受 text/plain 还有 text/html 的请求了。</p><p><strong>使用 @RequestMapping 来处理请求参数</strong></p><p>@RequestMapping 直接的 params 元素可以进一步帮助我们缩小请求映射的定位范围。使用 params 元素，你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。你可以用 myParams = myValue 这种格式来定义参数，也可以使用通配符来指定特定的参数值在请求中是不受支持的。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/fetch", params = {"personId=10"})          String getParams(@RequestParam("personId") String id) {        return "Fetched parameter = " + id;          }          @RequestMapping(value = "/fetch", params = {"personId=20"})          String getParamsDifferent(@RequestParam("personId") String id) {                  return "Fetched parameter = " + id;          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，getParams() 和 getParamsDifferent() 两个方法都能处理相同的一个 URL (/home/fetch) ，但是会根据 params 元素的配置不同而决定具体来执行哪一个方法。例如，当 URL 是 /home/fetch?id=10 的时候, getParams() 会执行，因为 id 的值是10,。对于 localhost:8080/home/fetch?personId=20 这个URL, getParamsDifferent() 处理方法会得到执行，因为 id 值是 20。</p><p><strong>使用 @RequestMapping 处理动态 URI</strong></p><p>@RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI，URI 的值可以作为控制器中处理方法的参数。你也可以使用正则表达式来只处理可以匹配到正则表达式的动态 URI。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping(value = "/fetch/{id}", method = RequestMethod.GET)      String getDynamicUriValue(@PathVariable String id) {        System.out.println("ID is " + id);                 return "Dynamic URI parameter fetched";          }          @RequestMapping(value = "fetch/{id:[a-z]+}/{name}", method = RequestMethod.GET)          String getDynamicUriValueRegex(@PathVariable("name") String name) {                  System.out.println("Name is " + name);                  return "Dynamic URI parameter fetched using regex";     }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，方法 getDynamicUriValue() 会在发起到 localhost:8080/home/fetch/10 的请求时执行。这里 getDynamicUriValue() 方法 id 参数也会动态地被填充为 10 这个值。方法 getDynamicUriValueRegex() 会在发起到 localhost:8080/home/fetch/category/shirt 的请求时执行。不过，如果发起的请求是 /home/fetch/10/shirt 的话，会抛出异常，因为这个URI并不能匹配正则表达式。@PathVariable 同 @RequestParam的运行方式不同。你使用 @PathVariable 是为了从 URI 里取到查询参数值。换言之，你使用 @RequestParam 是为了从 URI 模板中获取参数值。</p><p><strong>@RequestMapping 默认的处理方法</strong></p><p>在控制器类中，你可以有一个默认的处理方法，它可以在有一个向默认 URI 发起的请求时被执行。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController  @RequestMapping("/home")  public class IndexController {          @RequestMapping()          String default () {                  return "This is a default method for the class";         }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，向 /home 发起的一个请求将会由 default() 来处理，因为注解并没有指定任何值。</p><p><strong>@RequestMapping 快捷方式</strong></p><p>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。方法级别的注解变体有如下几个：@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping如下代码展示了如何使用组合注解：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@RestController @RequestMapping("/home")  public class IndexController {         @GetMapping("/person")          public @ResponseBody ResponseEntity <String> getPerson({        return new ResponseEntity < String > ("Response from GET", HttpStatus.OK);          }          @GetMapping("/person/{id}")          public @ResponseBody ResponseEntity < String > getPersonById(@PathVariable String id) {                 return new ResponseEntity < String > ("Response from GET with id " + id, HttpStatus.OK);          }          @PostMapping("/person")          public @ResponseBody ResponseEntity < String > postPerson() {                  return new ResponseEntity < String > ("Response from POST method", HttpStatus.OK);          }       @PutMapping("/person")          public @ResponseBody ResponseEntity < String > putPerson() {                  return new ResponseEntity < String > ("Response from PUT method", HttpStatus.OK);          }    @DeleteMapping("/person")          public @ResponseBody ResponseEntity < String > deletePerson() {                  return new ResponseEntity < String > ("Response from DELETE method", HttpStatus.OK);          }      @PatchMapping("/person")          public @ResponseBody ResponseEntity < String > patchPerson() {              return new ResponseEntity < String > ("Response from PATCH method", HttpStatus.OK);          }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，每一个处理方法都使用 @RequestMapping 的组合变体进行了注解。尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现, 但组合变体仍然是一种最佳的实践 — 这主要是因为组合注解减少了在应用程序上要配置的元数据，并且代码也更易读。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop项目配置</title>
      <link href="2020/01/14/hadoop-xiang-mu-pei-zhi/"/>
      <url>2020/01/14/hadoop-xiang-mu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-查看Java安装路径"><a href="#1-查看Java安装路径" class="headerlink" title="1.查看Java安装路径"></a>1.查看Java安装路径</h2><pre><code>update-alternatives --display java&gt;&gt; /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java</code></pre><p>hadoop安装在以下位置: /usr/local/hadoop</p><h2 id="2-Hadoop-环境变量配置"><a href="#2-Hadoop-环境变量配置" class="headerlink" title="2.Hadoop 环境变量配置"></a>2.Hadoop 环境变量配置</h2><p>.bashrc配置 【~/.bashrc: 当前用户 /etc/profile: 所有用户 终端：仅当前终端窗口】</p><h3 id="HOME文件夹配置"><a href="#HOME文件夹配置" class="headerlink" title="HOME文件夹配置"></a>HOME文件夹配置</h3><pre><code>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export HADOOP_HOME=/usr/local/hadoop</code></pre><h3 id="具体环境配置"><a href="#具体环境配置" class="headerlink" title="具体环境配置"></a>具体环境配置</h3><pre><code>export PATH=$PATH:$HADOOP_HOME/bin  # 各项运行文件，包括Hadoop、HDFS、YARN等。export PATH=$PATH:$HADOOP_HOME/sbin  # shell运行文件export HADOOP_MAPRED_HOME=$HADOOP_HOME  # 单机版，所以MapReduce、HDFS、YARN等都在一个文件夹？export HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/naitve  # 一些函数库配置export HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"  # 指定非Java类包的位置export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH  # 动态链接库的位置</code></pre><h2 id="3-Hadoop配置设置文件"><a href="#3-Hadoop配置设置文件" class="headerlink" title="3.Hadoop配置设置文件"></a>3.Hadoop配置设置文件</h2><h3 id="Hadoop-env-sh"><a href="#Hadoop-env-sh" class="headerlink" title="Hadoop-env.sh"></a>Hadoop-env.sh</h3><pre><code>export JAVA_HOME=${JAVA_HOME} &gt;&gt;export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64</code></pre><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><h4 id="设置HDFS的默认名称"><a href="#设置HDFS的默认名称" class="headerlink" title="设置HDFS的默认名称"></a>设置HDFS的默认名称</h4><pre><code>&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;fs.default.name&lt;/name&gt;    &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="yarn-site-xml-MapReduce2-YARN-相关配置"><a href="#yarn-site-xml-MapReduce2-YARN-相关配置" class="headerlink" title="yarn-site.xml MapReduce2 (YARN)相关配置"></a>yarn-site.xml MapReduce2 (YARN)相关配置</h4><pre><code>&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;    &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;&lt;/property&gt;</code></pre><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><pre><code>&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><pre><code>&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;  # blocks副本备份数量    &lt;value&gt;3&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;  # NameNode数据存储目录    &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/namenode&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;  # DataNode数据存储    &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/datanode&lt;/value&gt;&lt;/property&gt;</code></pre><h2 id="4-创建并格式化HDFS目录"><a href="#4-创建并格式化HDFS目录" class="headerlink" title="4.创建并格式化HDFS目录"></a>4.创建并格式化HDFS目录</h2><h3 id="创建NameNode数据存储目录"><a href="#创建NameNode数据存储目录" class="headerlink" title="创建NameNode数据存储目录"></a>创建NameNode数据存储目录</h3><h3 id="创建DataNode数据存储目录"><a href="#创建DataNode数据存储目录" class="headerlink" title="创建DataNode数据存储目录"></a>创建DataNode数据存储目录</h3><h3 id="将Hadoop目录所有者更改为hduser"><a href="#将Hadoop目录所有者更改为hduser" class="headerlink" title="将Hadoop目录所有者更改为hduser"></a>将Hadoop目录所有者更改为hduser</h3><pre><code>chown hduser:hduser -R /usr/local/hadoop</code></pre><h2 id="5-data1服务器-ip设置"><a href="#5-data1服务器-ip设置" class="headerlink" title="5.data1服务器 ip设置"></a>5.data1服务器 ip设置</h2><pre><code>vi /etc/network/interfaces# NAT interfaceauto eth0iface eth0 inet dhcp# host only interfaceiface eth1 inet staticaddress    192.168.56.101netmask    255.255.255.0network    192.168.56.0    broadcast    192.168.56.255</code></pre><h3 id="更改hostname"><a href="#更改hostname" class="headerlink" title="更改hostname"></a>更改hostname</h3><pre><code>/etc/hostnamedata1</code></pre><h3 id="编辑host文件"><a href="#编辑host文件" class="headerlink" title="编辑host文件"></a>编辑host文件</h3><pre><code>/etc/hosts192.168.56.100    master192.168.56.101    data1192.168.56.102    data2192.168.56.103    data3</code></pre><h3 id="core-site-xml-1"><a href="#core-site-xml-1" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p>localhost改为master</p><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><pre><code>&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;    &lt;value&gt;master:8025&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;    &lt;value&gt;master:8030&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;    &lt;value&gt;master:8050&lt;/value&gt;&lt;/property&gt;</code></pre><h3 id="mapred-site-xml-1"><a href="#mapred-site-xml-1" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><pre><code>&lt;property&gt;    &lt;name&gt;mapred.job.tracker&lt;/name&gt;    &lt;value&gt;master:54311&lt;/value&gt;&lt;/property&gt;</code></pre><h3 id="hdfs-site-xml-1"><a href="#hdfs-site-xml-1" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>删除namenode配置，保留DataNode配置</p><pre><code>&lt;property&gt;    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;  # DataNode数据存储    &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/datanode&lt;/value&gt;&lt;/property&gt;</code></pre><p>ifconfig 确认两个网卡,内网ip是192.168.56.101。对外网络连接正常</p><p>复制data1服务器到data2、data3,更改以上必要设置</p><h2 id="6-master服务器-ip设置、hostname设置"><a href="#6-master服务器-ip设置、hostname设置" class="headerlink" title="6.master服务器 ip设置、hostname设置"></a>6.master服务器 ip设置、hostname设置</h2><h3 id="hdfs-site-xml-2"><a href="#hdfs-site-xml-2" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>删除DataNode配置，保留NameNode配置</p><pre><code>&lt;property&gt;    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;  # NameNode数据存储目录    &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/namenode&lt;/value&gt;&lt;/property&gt;</code></pre><h3 id="编辑master文件"><a href="#编辑master文件" class="headerlink" title="编辑master文件"></a>编辑master文件</h3><pre><code>/usr/local/hadoop/etc/hadoop/masters</code></pre><h3 id="编辑slaves文件"><a href="#编辑slaves文件" class="headerlink" title="编辑slaves文件"></a>编辑slaves文件</h3><pre><code>/usr/local/hadoop/etc/hadoop/slaves</code></pre>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
